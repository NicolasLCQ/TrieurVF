'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var createLimiter = require('../index');

// Test function for resolving promises
var testResolvedFunction = function testResolvedFunction(value) {
  return new Promise(function (resolve) {
    return setTimeout(function () {
      return resolve(value);
    }, 10);
  });
};

// Test functions for rejecting promises
var testRejectedFunction = function testRejectedFunction(value) {
  return new Promise(function (resolve, reject) {
    return setTimeout(function () {
      return reject(value);
    }, 10);
  });
};

test('should work on import', function () {
  expect(typeof createLimiter === 'undefined' ? 'undefined' : _typeof(createLimiter)).toBe('function');
});

test('should create a limiter function', function () {
  var limit = createLimiter(1);
  expect(typeof limit === 'undefined' ? 'undefined' : _typeof(limit)).toBe('function');
});

test('should work with resolved promises', function () {
  var limit = createLimiter(1);
  return Promise.all([limit(testResolvedFunction)(3).then(function (result) {
    return expect(result).toBe(3);
  }), limit(testResolvedFunction)(4).then(function (result) {
    return expect(result).toBe(4);
  })]);
});

test('should work with rejected promises', function () {
  var limit = createLimiter(1);
  return Promise.all([limit(testRejectedFunction)(5).catch(function (reason) {
    return expect(reason).toBe(5);
  }), limit(testRejectedFunction)(6).catch(function (reason) {
    return expect(reason).toBe(6);
  })]);
});